// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `build_authorize_url`, `build_code_challenge`, `build_code_verifier`, `convert_expires_in`, `exchange_code_for_tokens`, `normalize_scopes`, `persist_tokens`, `random_string`, `record_from_tokens`, `send_browser_response`, `wait_for_code`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `TokenResponse`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `fmt`, `from`

Future<AuthTokens> authenticateViaBrowser({
  required String clientId,
  required List<String> scopes,
}) => RustLib.instance.api.crateApiAuthAuthAuthenticateViaBrowser(
  clientId: clientId,
  scopes: scopes,
);

Future<void> persistAuthState({
  required String clientId,
  required AuthTokens tokens,
}) => RustLib.instance.api.crateApiAuthAuthPersistAuthState(
  clientId: clientId,
  tokens: tokens,
);

Future<StoredAuthState?> loadPersistedAuthState() =>
    RustLib.instance.api.crateApiAuthAuthLoadPersistedAuthState();

Future<void> clearPersistedAuthState() =>
    RustLib.instance.api.crateApiAuthAuthClearPersistedAuthState();

class AuthTokens {
  final String accessToken;
  final String? refreshToken;
  final BigInt? expiresIn;
  final String? idToken;
  final String? scope;
  final String? tokenType;

  const AuthTokens({
    required this.accessToken,
    this.refreshToken,
    this.expiresIn,
    this.idToken,
    this.scope,
    this.tokenType,
  });

  @override
  int get hashCode =>
      accessToken.hashCode ^
      refreshToken.hashCode ^
      expiresIn.hashCode ^
      idToken.hashCode ^
      scope.hashCode ^
      tokenType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AuthTokens &&
          runtimeType == other.runtimeType &&
          accessToken == other.accessToken &&
          refreshToken == other.refreshToken &&
          expiresIn == other.expiresIn &&
          idToken == other.idToken &&
          scope == other.scope &&
          tokenType == other.tokenType;
}

class StoredAuthState {
  final String clientId;
  final AuthTokens tokens;
  final PlatformInt64 updatedAtMillis;

  const StoredAuthState({
    required this.clientId,
    required this.tokens,
    required this.updatedAtMillis,
  });

  @override
  int get hashCode =>
      clientId.hashCode ^ tokens.hashCode ^ updatedAtMillis.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StoredAuthState &&
          runtimeType == other.runtimeType &&
          clientId == other.clientId &&
          tokens == other.tokens &&
          updatedAtMillis == other.updatedAtMillis;
}
