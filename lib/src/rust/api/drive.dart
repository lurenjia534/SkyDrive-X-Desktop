// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `best_url`, `build_children_url`, `current_access_token`, `fetch_drive_children`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `DriveChildrenResponse`, `DriveFileFacet`, `DriveFolderFacet`, `DriveItemDto`, `ThumbnailDto`, `ThumbnailSetDto`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`

Future<DrivePage> listDriveChildren({
  String? folderId,
  String? folderPath,
  String? nextLink,
}) => RustLib.instance.api.crateApiDriveListDriveChildren(
  folderId: folderId,
  folderPath: folderPath,
  nextLink: nextLink,
);

class DriveItemSummary {
  final String id;
  final String name;
  final BigInt? size;
  final bool isFolder;
  final PlatformInt64? childCount;
  final String? mimeType;
  final String? lastModified;
  final String? thumbnailUrl;

  const DriveItemSummary({
    required this.id,
    required this.name,
    this.size,
    required this.isFolder,
    this.childCount,
    this.mimeType,
    this.lastModified,
    this.thumbnailUrl,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      size.hashCode ^
      isFolder.hashCode ^
      childCount.hashCode ^
      mimeType.hashCode ^
      lastModified.hashCode ^
      thumbnailUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DriveItemSummary &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          size == other.size &&
          isFolder == other.isFolder &&
          childCount == other.childCount &&
          mimeType == other.mimeType &&
          lastModified == other.lastModified &&
          thumbnailUrl == other.thumbnailUrl;
}

class DrivePage {
  final List<DriveItemSummary> items;
  final String? nextLink;

  const DrivePage({required this.items, this.nextLink});

  @override
  int get hashCode => items.hashCode ^ nextLink.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DrivePage &&
          runtimeType == other.runtimeType &&
          items == other.items &&
          nextLink == other.nextLink;
}
